---
title: How to set up MCP analytics and error tracking
date: 2025-10-14
author:
  - arda-eren
tags:
  - MCP
  - product analytics
  - feature flags
---

MCP servers give LLMs powerful capabilities, but without analytics and error tracking you're flying blind with no visibility into usage or performance. Which tools get called? How often? Where are the bottlenecks? What's failing?

This tutorial will show you how to add product analytics and error tracking to any MCP server using a simple wrapper pattern. You'll automatically track every tool execution without touching your business logic. 

By the end, your MCP server will be able to:

- Track execution time for every tool call
- Capture errors with context
- Record custom metrics

The full source code is available in this [GitHub repository](https://github.com/arda-e/mcp-posthog-analytics).

## Prerequisites

- Node.js 18+ 
- PostHog account (free tier)
- Claude Desktop or another MCP client to test your MCP server
- Basic TypeScript knowledge
- Code editor (e.g., VS Code, Cursor)

## Quickstart

### 1) Install dependencies
```bash
npm init -y
npm install @modelcontextprotocol/sdk posthog-node zod dotenv
npm install --save-dev typescript @types/node tsx
```

### 2) Add scripts to package.json
```json file="./package.json"
{
  "type": "module",
  "scripts": {
    "build": "tsc"
  }
}
```

### 3) Create tsconfig.json
```json file="./tsconfig.json"
{
  "compilerOptions": {
    "target": "ES2022",
    "module": "ESNext",
    "moduleResolution": "bundler",
    "outDir": "./build",
    "rootDir": "./src",
    "strict": true,
    "esModuleInterop": true,
    "skipLibCheck": true,
    "forceConsistentCasingInFileNames": true
  },
  "include": ["src/**/*"]
}
```

## Building a Simple MCP Server

### 1) Create the entry point. 

```typescript file="./src/index.ts"
import "dotenv/config";
import { startStdioServer } from "./server.js";

async function main() {
  const handle = await startStdioServer();

  process.on("SIGINT", async () => {
    await stopStdioServer(handle);
  });
}
}

main().catch(console.error);
```

### 2) Create basic server without analytics

```typescript file="./src/server.ts"
import { McpServer } from "@modelcontextprotocol/sdk/server/mcp.js";
import { StdioServerTransport } from "@modelcontextprotocol/sdk/server/stdio.js";
import * as tools from "./tools.js";
import { z } from "zod";
import { AnalyticsProvider, withAnalytics } from "./analytics.js";

export interface StdioServerHandle {
  server: McpServer;
  transport: StdioServerTransport;
}

async function buildStdioServer(analytics?: AnalyticsProvider): Promise<McpServer> {
  const server = new McpServer({
    name: "mcp-analytics-server",
    version: "1.0.0",
    capabilities: {
      resources: {},
      tools: {},
    },
  });

  return server;
}

export async function startStdioServer(
): Promise<StdioServerHandle> {
  const server = await buildStdioServer();
  const transport = new StdioServerTransport();
  await server.connect(transport);

  console.error("[SERVER] MCP Server running on stdio");

  return { server, transport };
}

export async function stopStdioServer(
  handle: StdioServerHandle,
  analytics?: AnalyticsProvider
): Promise<void> {
  try {
    if(handle.server) await handle.server.close();
    console.error("[SERVER] Server stopped");
    process.exit(0);
  } catch (err) {
    console.error("[SERVER] Error during server shutdown:", err);
  }
}
```

### 3) Create Tools

Now that our server is ready, let's create our MCP tools in a new `tools.ts` file. 
For this tutorial, we'll hardcode simple datasets and results for the tools to fetch. 

```typescript file="./src/tools.ts"
/**
* In-memory inventory (pretend this is a database)
*/
const products = [
  { id: "1", name: "Laptop", price: 999, stock: 5 },
  { id: "2", name: "Mouse", price: 29, stock: 50 },
  { id: "3", name: "Keyboard", price: 79, stock: 25 }
];

export async function getInventory() {
  console.error("[Tool] getInventory called");
  return {
    content: [
      { type: "text" as const, text: JSON.stringify(products, null, 2) }
    ]
  };
}

export async function checkStock(productId: string) {
  console.error(`[Tool] checkStock called for product: ${productId}`);

  const product = products.find((p) => p.id === productId);
  if (!product) {
    throw new Error(`Product ${productId} not found`);
  }

  return {
    content: [
      { type: "text" as const, text: `${product.name}: ${product.stock} units in stock` }
    ]
  };
}

export async function analyzeData(data: string) {
  console.error(`[Tool] analyzeData called with data: ${data}`);
  setTimeout(() => {}, 1000);
  return {
    content: [
      { type: "text" as const, text: `Analyzed data: ${data}` }
    ]
  };
}

export async function riskyOperation() {
  console.error("[Tool] riskyOperation called");
  const success = Math.random() > 0.5;
  if (!success) {
    throw new Error("Risky operation failed");
  }
  return {
    content: [
      { type: "text" as const, text: "Risky operation succeeded" }
    ]
  };
}
```
Notice that these tools contain *only* business logic, with zero analytics dependencies. 
Keeping your tool definitions decoupled from other external logic makes them easier to test, maintain, and reuse across different contexts.

## MCP's Design Choices

MCP servers have an architecture that makes the wrapper pattern a natural fit for extended functionality like analytics and error tracking. 
Why? MCP's functional design means wrapper patterns work seamlessly, unlike other web frameworks with middleware pipelines or class-based systems with decorators.

Here's what the boilerplate code looks like for MCP tool registration: 

```typescript
// This is how MCP tools are registered, already functional style
server.tool(
  "toolName",
  { /* schema */ },
  { /* metadata */ },
  async (args) => { /* handler function */ }
);
```

Since MCP tools are mostly just async functions passed to `server.tool()`, wrapping the handler function is a clean and lightweight way of adding or extending functionality â€“ in this case, analytics.


## Implementing Analytics

### 1. Define the MCP analytics provider
The first step is define an interface for an analytics provider. 
It defines a standard set of methods for sending analytics data from your MCP server.

We'll give it three core abilities:

Track tool calls
Capture errors
Close the analytics client

```typescript file="./src/analytics.ts"
export interface AnalyticsProvider {
  /**
   * Track a successful tool execution with timing information
   * @param toolName - Name of the tool that was executed
   * @param result - Execution results including duration and success status
   */
  trackTool(toolName: string, result: any): Promise<void>;
  
  /**
   * Track an error that occurred during tool execution
   * @param error - The error object that was thrown
   * @param context - Additional context about the error (tool name, duration, etc.)
   */
  trackError(error: Error, context: any): Promise<void>;
  
  /**
   * Gracefully shut down the analytics client and flush pending events
   */
  close(): Promise<void>;
}
```

This approach makes your code testable and flexible. Think of it as a generic adapter for analytics calls.
Want to use a different analytics provider? Write a new implementation. Need to debug locally? Create a file-based logger. Running tests? Use a no-emit version that tracks calls without sending data.

### 2. Create the withAnalytics wrapper  

The next step is create a wrapper that intercepts every tool call. The wrapper function is responsible for invoking the analytics provider methods we defined in the previous step.

```typescript file="./src/analytics.ts"
export async function withAnalytics<T>(
  analytics: AnalyticsProvider | undefined,
  toolName: string,
  handler: () => Promise<T>
): Promise<T> {
  const start = Date.now();
  
  try {
    const result = await handler();
    const duration_ms = Date.now() - start;
    
    // Track successful execution
    await analytics?.trackTool(toolName, { 
      duration_ms, 
      success: true 
    });
    
    return result;
    
  } catch (error) {
    const duration_ms = Date.now() - start;
    
    // Track the error with context
    await analytics?.trackError(error as Error, {
      tool_name: toolName,
      duration_ms
    });
    
    throw error; // Re-throw so MCP handles it normally
  }
}
```

The withAnalytics() wrapper function:

- Times every tool call execution
- Tracks success/failure
- Preserves normal error handling
- Works without an analytics provider

### 3. Register tools with analytics

Now it's time to register your tools with the MCP server. 
Let's start by wrapping each handler function with the `withAnalytics()` wrapper in `server.ts` we implemented earlier.

```typescript file="src/server.ts"
import { McpServer } from "@modelcontextprotocol/sdk/server/mcp.js";
import { StdioServerTransport } from "@modelcontextprotocol/sdk/server/stdio.js";
import * as tools from "./tools.js";
import { z } from "zod";
import { AnalyticsProvider, withAnalytics } from "./analytics.js";

export interface StdioServerHandle {
  server: McpServer;
  transport: StdioServerTransport;
}

async function buildStdioServer(analytics?: AnalyticsProvider): Promise<McpServer> {
  const server = new McpServer({
    name: "mcp-analytics-server",
    version: "1.0.0",
    capabilities: {
      resources: {},
      tools: {},
    },
  });

  server.tool(
    "getInventory",
    {},
    { title: "Get product inventory" },
    async () => withAnalytics(analytics, "getInventory", () => tools.getInventory())
  );

  server.tool(
    "checkStock",
    { productId: z.string() },
    { title: "Get stock for a specified product" },
    async (args) => withAnalytics(analytics, "checkStock", () => tools.checkStock(args.productId))
  );

  server.tool(
    "analyze_data",
    { data: z.string() },
    { title: "Analyze data (slow)" },
    async (args) => withAnalytics(analytics, "analyze_data", () => tools.analyzeData(args.data))
  );


  server.tool(
    "risky_operation",
    {},
    { title: "Operation that sometimes fails" },
    async () => withAnalytics(analytics, "risky_operation", () => tools.riskyOperation())
  );

  return server;
}

export async function startStdioServer(
    analytics?: AnalyticsProvider
): Promise<StdioServerHandle> {
  const server = await buildStdioServer(analytics);
  const transport = new StdioServerTransport();
  await server.connect(transport);

  console.error("[SERVER] MCP Server running on stdio");

  return { server, transport };
}

export async function stopStdioServer(
  handle: StdioServerHandle,
  analytics?: AnalyticsProvider
): Promise<void> {
  try {
    if(handle.server) await handle.server.close();
    if(analytics) await analytics.close();
    console.error("[SERVER] Server stopped");
    process.exit(0);
  } catch (err) {
    console.error("[SERVER] Error during server shutdown:", err);
  }
}
```

If you want capture additional custom properties, you can adapt the wrapper pattern and call the `trackTool()` method with the additional properties.

```typescript file="src/server.ts"
server.tool(
  "getInventory",
  {},
  { title: "Get product inventory" },
  async () => withAnalytics(
    analytics,
    "getInventory",
    async () => {
      const result = await tools.getInventory();
      
      // Track additional custom metrics as a SEPARATE event
      await analytics?.trackTool("inventory_metrics", {
        duration_ms: 0,
        success: true,
        items_returned: result.length,
        cache_hit: false
      });
      
      return result;
    }
  )
);
```

Now let's send those analytics somewhere useful. The next integration step is to initialize a PostHog SDK client that implements the `AnalyticsProvider` interface. 

```typescript file="./src/posthog.ts"
import { PostHog } from "posthog-node";
import { AnalyticsProvider } from "./analytics.js";

export class PostHogAnalyticsProvider implements AnalyticsProvider {
  private client: PostHog | null;
  private mcpInteractionId: string;

  /**
   * Initializes the analytics client with a unique session ID.
   */
  constructor(
    apiKey: string,
    options?: { host?: string; }
  ) {
    this.client = new PostHog(apiKey, { host: options?.host });
    this.mcpInteractionId = `mcp_${Date.now()}_${process.pid}`;

    console.error(
      `[Analytics] Initialized with session ID: ${this.mcpInteractionId}`
    );
  }

  async trackTool(
    toolName: string,
    result: {
      duration_ms: number;
      success: boolean;
      [key: string]: any;
    }
  ): Promise<void> {
    this.client?.capture({
      distinctId: this.mcpInteractionId,
      event: "tool_executed",
      properties: { tool_name: toolName, ...result },
    });

    console.error(
      `[Analytics] ${toolName}: ${result.success ? "âœ“" : "âœ—"} (${
        result.duration_ms
      }ms)`
    );
  }

  async trackError(
    error: Error,
    context: {
      tool_name: string;
      duration_ms: number;
      args?: Record<string, unknown>;
      [key: string]: any;
    }
  ): Promise<void> {

    this.client?.captureException(error, this.mcpInteractionId, {
      duration_ms: context.duration_ms,
      tool_name: context.tool_name,
    });

    console.error(
      `[Analytics] ERROR in ${context.tool_name}: ${error.message}`
    );
  }

  async close(): Promise<void> {
    try {
      // If you wish to continue using PostHog after closing the client,
      // you can use client.flush() instead of client.shutdown()
      await this.client?.shutdown();
      console.error("[Analytics] Closed");
    } catch (error) {
      console.error("[Analytics] Error during close:", error);
    }
  }
}
```

Let's inject the AnalyticsProvider implementation to our server and dependent functions.

```typescript file="./src/index.ts"
import "dotenv/config";
import { startStdioServer, stopStdioServer } from "./server.js";
import { AnalyticsProvider } from "./analytics.js";
import { PostHogAnalyticsProvider } from "./posthog.js";

const apiKey = process.env.POSTHOG_API_KEY;
const host = process.env.POSTHOG_HOST;

async function main() {
  let analytics: AnalyticsProvider | undefined = undefined;
  
  if(!apiKey) {
    console.error("[SERVER] POSTHOG_API_KEY is not set, continue without analytics");
  }

  try {
    if(apiKey) analytics = new PostHogAnalyticsProvider(apiKey, { host });
    const handle = await startStdioServer(analytics);

    process.on("SIGINT", async () => await stopStdioServer(handle,analytics));
    process.on("SIGTERM", async () => await stopStdioServer(handle, analytics));

    await new Promise(() => {});

  } catch (err) {
    console.error("[SERVER] Error during server startup:", err);
    process.exit(1);
  }
}

(async () => {
  await main();
})();
```

## Hooking up our server with an MCP Client - Claude Desktop

Now we can test our MCP server with Claude Desktop, or any compatible MCP client, to see MCP analytics in action.

Build the MCP server:

```bash
npm install && npm run build
```

Note: The client will run our server as a child process so we don't need to run our server in our terminal. 
We modify the claude's config file to make sure the Claude Desktop can run our build. 

```json file="~/Library/Application Support/Claude/claude_desktop_config.json"
{
  "mcpServers": {
    "analytics-demo": {
      "command": "/path/to/node",
      "args": ["/path/to/project/build/index.js"],
      "env": {
        "POSTHOG_API_KEY": "<ph_project_api_key>",
        "POSTHOG_HOST": "<ph_client_api_host>" // e.g. https://us.i.posthog.com
      }
    }
  }
}
```

Restart Claude Desktop & try these prompts:

- "Show me the inventory" â†’ Should successfully return the inventory.
- "Check stock for product 999" â†’ Should throw an error.
- "Analyze this data: quarterly sales" â†’ Simulates a slow operation.

<ProductVideo
  videoLight="https://res.cloudinary.com/dmukukwp6/video/upload/mcp_tool_call_compressed_bc097fc4ae.mp4"
  alt="MCP server tool calls with Claude Desktop"
  classes="rounded"
  autoPlay={true}
  loop={true}
/>

<Caption>
Our MCP server executing tool calls.
</Caption>

## 8. Create MCP analytics dashboards

Now that our MCP server is creating MCP analytics, we can create insights and dashboards in PostHog to visualize the data. We can create:

 - Performance dashboard
 - Reliability dashboard
 - Usage dashboard

Image tk...

<Caption>
P95 latency by tool (bar chart) to find slow operations
</Caption>

Image tk...

<Caption>
Success rate by tool (table) to identify problem areas
</Caption>

Image tk...

<Caption>
Tool popularity over time (line chart) to understand patterns
</Caption>

## Further reading

- Complete code on [GitHub](https://github.com/arda-e/mcp-posthog-analytics)
- [MCP: machine copy/paste](/blog/machine-copy-paste-mcp-intro)
- [What we've learned about AI-powered features](/newsletter/building-ai-features)
- [Avoid these AI coding mistakes](/newsletter/ai-coding-mistakes)
