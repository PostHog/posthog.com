We recommend you call `identify` [as soon as you're able](#1-call-identify-as-soon-as-youre-able), typically when a user signs up or logs in.

This doesn't work if one or both platforms are unauthenticated. Some examples of such cases are:
- Onboarding and signup flows before authentication.
- Unauthenticated web pages redirecting to authenticated mobile apps.
- Authenticated web apps prompting an app download.

In these cases, you can use a [deep link](https://developer.android.com/training/app-links/deep-linking) on Android and [universal links](https://developer.apple.com/documentation/xcode/supporting-universal-links-in-your-app) on iOS to identify users.

1. Use `posthog.get_distinct_id()` to get the current distinct ID. Even if you cannot call identify because the user is unauthenticated, this will return an anonymous distinct ID generated by PostHog.
2. Add the distinct ID to the deep link as query parameters, along with other properties like UTM parameters.
3. When the user is redirected to the app, parse the deep link and handle the following cases:
  - The user is already authenticated on the mobile app. In this case, call [`posthog.alias()`](/docs/libraries/js/features#alias) with the distinct ID from the web. This associates the two distinct IDs as a single person.
  - The user is unauthenticated. In this case, call [`posthog.identify()`](/docs/libraries/js/features#identifying-users) with the distinct ID from the web. Events will be associated with this distinct ID.

As long as you associate the distinct IDs with `posthog.identify()` or `posthog.alias()`, you can track events generated across platforms.

Here's an example implementation for handling deep links from web to mobile:

<MultiLanguage selector="tabs">

```ios_swift
import PostHog

class DeepLinkIdentityManager {
    static let shared = DeepLinkIdentityManager()

    private var identifiedViaDeepLink = false

    // MARK: - Deep Link Received

    func handleDeepLink(_ url: URL) {
        guard let webDistinctId = URLComponents(url: url, resolvingAgainstBaseURL: true)?
            .queryItems?.first(where: { $0.name == "ph_distinct_id" })?.value else {
            return
        }

        // Immediately identify with web's distinct_id
        // This connects app anon activity → web anon activity
        PostHogSDK.shared.identify(webDistinctId)
        identifiedViaDeepLink = true
    }

    // MARK: - Login/Signup

    func handleLogin(canonicalUserId: String) {
        if identifiedViaDeepLink {
            // Deep link path: already identified with web ID
            // Alias merges web anon chain → canonical user ID
            PostHogSDK.shared.alias(canonicalUserId)
        } else {
            // Normal path: no deep link
            PostHogSDK.shared.identify(canonicalUserId)
        }

        identifiedViaDeepLink = false
        // Set user properties, track signup event, etc.
    }

    func handleLogout() {
        PostHogSDK.shared.reset()
        identifiedViaDeepLink = false
    }
}
```

```android_kotlin
import android.net.Uri
import com.posthog.PostHog

object DeepLinkIdentityManager {

    private var identifiedViaDeepLink = false

    // Deep Link Received

    fun handleDeepLink(uri: Uri) {
        val webDistinctId = uri.getQueryParameter("ph_distinct_id") ?: return

        // Immediately identify with web's distinct_id
        // This connects app anon activity → web anon activity
        PostHog.identify(webDistinctId)
        identifiedViaDeepLink = true
    }

    // Login/Signup

    fun handleLogin(canonicalUserId: String) {
        if (identifiedViaDeepLink) {
            // Deep link path: already identified with web ID
            // Alias merges web anon chain → canonical user ID
            PostHog.alias(canonicalUserId)
        } else {
            // Normal path: no deep link
            PostHog.identify(canonicalUserId)
        }

        identifiedViaDeepLink = false
        // Set user properties, track signup event, etc.
    }

    fun handleLogout() {
        PostHog.reset()
        identifiedViaDeepLink = false
    }
}
```

</MultiLanguage>