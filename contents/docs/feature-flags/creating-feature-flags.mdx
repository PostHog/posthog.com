---
title: Creating feature flags
sidebar: Docs
showTitle: true
availability:
    free: full
    selfServe: full
    enterprise: full
---
import { ProductScreenshot } from 'components/ProductScreenshot'
import { CalloutBox } from 'components/Docs/CalloutBox'
export const CreateNewFeatureFlagLight = "https://res.cloudinary.com/dmukukwp6/image/upload/w_1600,c_limit,q_auto,f_auto/create_feature_flags_light_133081fabc.png"
export const CreateNewFeatureFlagDark = "https://res.cloudinary.com/dmukukwp6/image/upload/w_1600,c_limit,q_auto,f_auto/create_feature_flags_dark_8aaa86aa47.png"
export const ReleaseConditionLight = "https://res.cloudinary.com/dmukukwp6/image/upload/posthog.com/contents/images/features/feature-flags/release-conditions-light-mode.png"
export const ReleaseConditionDark = "https://res.cloudinary.com/dmukukwp6/image/upload/posthog.com/contents/images/features/feature-flags/release-conditions-dark-mode.png"

Before you can evaluate a feature flag in your application code, you need to create it in PostHog. You need to configure the following for a new flag:

| Step | Configuration | Required? |
|------|---------------|----------|
| 1 | [Create a new feature flag](#step-1-create-a-new-feature-flag-required) | Required |
| 2 | [The key in your code used to evaluate the feature flag](#step-2-add-feature-flag-key-and-description-required) | Required |
| 3 | [The type of feature flag – boolean, multivariate, or remote config](#step-3-choose-a-feature-flag-type-required) | Required |
| 4 | [Additional feature flag behaviors](#step-4-configure-feature-flag-behavior-optional) | Optional |
| 5 | [Evaluation runtime and environments](#step-5-configure-evaluation-runtime-and-environments-optional) | Optional |

## Step 1. Create a new feature flag (required)

To create a new feature flag, navigate to the [feature flags tab](https://app.posthog.com/feature_flags) in PostHog and click the **Create feature flag** button to create a new flag.

This presents you with a form where you can complete the details of your new flag:

<details>
<summary>Migrate feature flags from another tool</summary>

If you can pull feature flag data from another tool programmatically, you can use [our API](/docs/api/feature-flags) to migrate them. We even wrote guides for doing this with [LaunchDarkly](/docs/migrate/launchdarkly) and [Statsig](/docs/migrate/statsig).

</details>

<ProductScreenshot
    imageLight={CreateNewFeatureFlagLight}
    imageDark={CreateNewFeatureFlagDark}
    alt="How to create a feature flag in PostHog"
    classes="rounded"
/>

## Step 2. Add feature flag key and description (required)

This is the _unique_ key you use in your code to evaluate the feature flag. Some examples of feature flag keys are `new-landing-page`, `betaFeature`, or `bigger_callout_button`.

You will later [evaluate the feature flag](/docs/feature-flags/adding-feature-flag-code) in your code using expressions like
- `posthog.isFeatureEnabled('new-landing-page')`
- `posthog.getFeatureFlag('betaFeature')`

Use a descriptive key that fits your code and is easy to understand. You should also include a **description** to help you and your team understand the purpose of the feature flag.

## Step 3. Choose a feature flag type (required)

In the **Served value** section, you can configure the type of feature flag you want to create. There are three types of feature flags:

| Flag type | Description |
|-----------|-------------|
| **Release toggle** <br/> <br/> (boolean) | These return `false` if the flag is disabled, `true` if the flag is enabled and has a matching release condition, and `null` or `undefined` if no release condition matches. |
| **Multiple variants with rollout percentages** <br/> <br/> (A/B/n test) | Instead of indicating enabled vs. disabled, multivariate flags return a key – for example, `control` or `test`.<br/><br/>You can choose the rollout percentage for each variant key, where each is given a specific percentage of the total audience. Users will then be randomly assigned to each variant based on these percentages. |
| **Remote config** <br/> <br/>(single payload) | While boolean and multivariate flags can be set up to serve different values to different users, remote config flags are meant to pass static configuration values to your applications at runtime. The config value is **always** passed in the flag's payload.<br/><br/>You can use remote config flags to tweak application configs on the fly without deploying code changes. |

You can select the type of feature flag by toggling between the selectors. Then, configure the payload and release conditions for the flag if applicable.

### Payloads

A payload is an additional piece of information sent to your app when a flag is matched for a user. The returned value can be any valid JSON type (object, array, number, string, boolean, or null).

They enable you to configure functionality related to your flag inside PostHog, instead of having to make code changes or redeploy your app.

If you're using remote config flags, you can use payloads to pass configuration values to your application.

### Release conditions

This specifies the conditions a user must meet to access the feature flag and receive a value. Release conditions do not apply to remote config flags.

Condition sets are evaluated from **top to bottom**, and the **first** condition set that matches will be used. A condition matches when all property filters pass and the target falls within the rollout percentage.

Percentage rollouts are available for all flags. More options depend on your PostHog setup:

- If GeoIP is enabled, you can target based on geographic location.

- If you capture identified events, you can target based on [person properties](/docs/product-analytics/person-properties) and [cohorts](/docs/data/cohorts).

- If you enabled group analytics, you can target based on [group properties](/docs/product-analytics/group-analytics#how-to-set-group-properties).

<ProductScreenshot
    imageLight={ReleaseConditionLight}
    imageDark={ReleaseConditionDark}
    alt="Feature flags release conditions"
    classes="rounded"
/>

#### Advanced release conditions

For more sophisticated feature rollouts, you can also create **feature flag dependencies** where one flag's activation depends on another flag's state. This enables complex scenarios like:

- Enabling features only for users in beta programs
- Creating conditional experiments based on other feature participation
- Setting up safety mechanisms where critical flags must be active first

Learn more about [feature flag dependencies](/docs/feature-flags/dependencies).

<CalloutBox icon="IconInfo" title="Limited dependencies with different run times" type="fyi">

Currently, [feature flag dependencies](/docs/feature-flags/dependencies) are limited when flags have different runtime environments. Ensure dependent flags share compatible runtime settings.

</CalloutBox>

## Step 4. Configure feature flag behavior (optional)

These are some _optional_ toggles for feature flag behavior. This section describes what they do and their default values.

### Enable feature flag (optional)

> Default: `Enabled`

This determines whether your flag is enabled on creation. Disabled flags return `undefined` or `null` when evaluated. You can always re-enable or disable the flag later.

### Create usage dashboard (optional)

> Default: `Enabled`

Automatically track how often this flag is called and what values are returned. Creates a dashboard with call volume trends and variant distribution insights.

### Persisting feature flags across authentication steps (optional)

> Default: `Disabled`
>
> **Note:** This is only relevant if your feature flag is shown to both logged out AND logged in users.

Feature flag values are calculated based on a user's properties. Since it's possible for a user to have different properties before and after login, they may receive different feature flag values before and after logging in.

By enabling the option to persist feature flags across authentication, you ensure that the flag value remains the same.

> **Note:** This feature requires `person_profiles: 'always'` and calling `posthog.identify` from the JavaScript Web SDK to function as expected. [Learn more about anonymous vs identified events here](/docs/data/anonymous-vs-identified-events).

In our experience, the tradeoffs to enabling this are **not** worthwhile for the majority of our users. They include:

1. **Slower feature flag response:** Enabling this option introduces additional checks, which can slow down the response time when fetching feature flags.
2. **Incompatible with [local evaluation](/docs/feature-flags/local-evaluation):** It is necessary to perform the additional checks on the PostHog servers.
3. **Incompatible with [bootstrapping](/docs/feature-flags/bootstrapping):** Bootstrapping relies on local evaluation, which cannot correctly calculate persistent flag values.

## Step 5. Configure evaluation runtime and contexts (optional)

You can control where your feature flags are evaluated using the **evaluation runtime** and **tags (evaluation contexts)** sections of the form. You can find a detailed explanation of how evaluation contexts work in the [evaluation contexts documentation](/docs/feature-flags/evaluation-contexts).

### Evaluation runtime (optional)

> Default: `Both client and server`
>
> By default, feature flags will be evaluated in all (both client and server) environments.

Feature flags can be configured to evaluate in one of three runtime environments:

| Runtime | Description |
|---------|-------------|
| **Both client and server** (default) | Flags are evaluated in both server and client environments |
| **Client-side only** | Flags are only evaluated on client-side SDKs (JavaScript, React, mobile SDKs) |
| **Server-side only** | Flags are only evaluated on server-side SDKs (Node.js, Python, Ruby, Go, PHP, etc.) |

<details>
<summary>How feature flags determine the current runtime</summary>

When you specify an evaluation runtime, PostHog automatically detects the requesting environment based on:

- `User-Agent` headers
- Browser-specific headers
- SDK type indicators

If you override any of these during capture, evaluation may not be accurate.

</details>

The system then filters which flags are returned based on their configured runtime, ensuring:
- Smaller payload sizes for client applications
- Reduced evaluation latency by eliminating irrelevant flags
- Prevention of feature flag bloat and better organization by environment
- Better security by keeping server-only flags away from client environments

If you're not sure which runtime to use, you can use the following guidelines:

1. **Use server-only evaluation** for:
   - Sensitive feature rollouts that shouldn't be exposed to clients
   - Backend system configurations
   - Internal features or admin capabilities

2. **Use client-only evaluation** for:
   - UI/UX experiments
   - Frontend-specific features
   - Visual changes that don't require backend logic

3. **Use "All" (default)** for:
   - Features that span both frontend and backend
   - Gradual rollouts that need consistent behavior across environments
   - When you're unsure or need maximum flexibility

### Tags and evaluation contexts (optional)

<CalloutBox icon="IconWarning" title="Evaluation contexts are in alpha release" type="caution">

Evaluation contexts are currently in alpha release. This feature may not be available in your PostHog instance yet. Contact support if you'd like early access. 

</CalloutBox>

Tags are a way to categorize your feature flags. Use them to describe when/where the flag is used in your application. Some common examples are:

- Application type (e.g., "main-app", "marketing-site", "docs")
- Platform (e.g., "web", "mobile", "api")
- Product area (e.g., "checkout", "onboarding", "admin")

When evaluation contexts are configured, the feature flag will only evaluate when the SDK provides matching evaluation contexts in the `/flags` request.

You can use tags to accomplish:

- **Application isolation**: Prevent flags from evaluating in unintended contexts (e.g., marketing site vs. app vs. docs)
- **Cost optimization**: Reduce unnecessary flag evaluations and associated costs
- **Better organization**: Group flags by their intended usage context
- **Backward compatible**: Flags without evaluation contexts continue to work as before
- **Prevent bloat**: Reduce unnecessary flag evaluations by only sending relevant flags to each context

<CalloutBox icon="IconWarning" title="Evaluation context tag behavior" type="action">

- SDKs must send `evaluation_contexts` parameter with matching tags for the flag to evaluate (the legacy `evaluation_environments` parameter is also supported)
- Flags with no evaluation context tags will evaluate for all requests (default behavior)
- At least one evaluation tag must match for the flag to be included in the evaluation

</CalloutBox>

We recommend reading the [evaluation contexts documentation](/docs/feature-flags/evaluation-contexts) in detail before using it in production.
