---
title: Send events
nextPage: ./identify-users.mdx
---

import Badge from "./\_snippets/badge.mdx"
import SendEventBackend from "./\_snippets/send-event-backend.mdx"

Once your PostHog instance is up and running, the next step is to start sending events.

## 1. Initialize PostHog <Badge>Client</Badge>

<MultiLanguage selector="tabs">

<!-- prettier-ignore -->
```html label=Snippet
<script>
    !function(t,e){var o,n,p,r;e.__SV||(window.posthog=e,e._i=[],e.init=function(i,s,a){function g(t,e){var o=e.split(".");2==o.length&&(t=t[o[0]],e=o[1]),t[e]=function(){t.push([e].concat(Array.prototype.slice.call(arguments,0)))}}(p=t.createElement("script")).type="text/javascript",p.async=!0,p.src=s.api_host+"/static/array.js",(r=t.getElementsByTagName("script")[0]).parentNode.insertBefore(p,r);var u=e;for(void 0!==a?u=e[a]=[]:a="posthog",u.people=u.people||[],u.toString=function(t){var e="posthog";return"posthog"!==a&&(e+="."+a),t||(e+=" (stub)"),e},u.people.toString=function(){return u.toString(1)+".people (stub)"},o="capture identify alias people.set people.set_once set_config register register_once unregister opt_out_capturing has_opted_out_capturing opt_in_capturing reset isFeatureEnabled onFeatureFlags".split(" "),n=0;n<o.length;n++)g(u,o[n]);e._i.push([i,s,a])},e.__SV=1)}(document,window.posthog||[]);
    posthog.init('<ph_project_api_key>', {api_host: '<ph_instance_address>'})
</script>
```

</MultiLanguage>

Paste this snippet within your website's `<head>` tags - ideally just inside the closing `</head>` tag - on all pages you want to track.

## 2. Setup autocapture <Badge>Client</Badge>

When you call `posthog.init` the PostHog JS library begins automatically capturing user events:

-   **Page views**, including the URL
-   **Autocaptured events**, such as any click, change of input, or submission associated with `a`, `button`, `form`, `input`, `select`, `textarea`, and `label` tags

### Hiding certain elements

PostHog puts significant effort into ensuring it doesn't capture sensitive data from your website.
However, if there are specific elements you want to ensure aren't captured, you can add the `ph-no-capture` class name.

```html
<input class='ph-no-capture'><!-- Input with sensitive user info --></input>
```

> **Tip**: Including the `ph-no-capture` class will also exclude elements from being shown in session recordings.

## 3. Capture custom events <Badge>Client</Badge>

Setting up autocapture is a great way to get started, but typically when integrating tracking into your product, you'll want to send additional events for when specific things occur.

On the client-side, we can use the `capture` method, with the first argument being the name of the event you want to track.

<MultiLanguage selector="tabs">

```js
posthog.capture('Sign-up button clicked')
```

</MultiLanguage>

> While you can name your events however you'd like, we typically recommend using a '[object] [verb]' format, where '[object]' is whatever entity the action relates to, and the '[verb]' is the action itself.
> Some examples of this could include: `Project created`, `User signed up`, or `Invite sent`.

At first, it may seem somewhat unnecessary to send these custom events when we already have autocapture setup, but these custom events are important for two main reasons:

1. Sending custom properties on an event
2. Keeping events consistent over time

### Sending custom properties

Suppose you're building an e-commerce store and want to track whenever a user adds an item to their cart.
With autocapture, you'll already see `Clicked button with text 'Add to cart'` events, but these won't have any information on the items the user added!

We include extra information on events by adding a second parameter in our capture call, which contains a map of custom property names and values.

<MultiLanguage selector="tabs">

```js
posthog.capture('Item added to cart', {
    sku: 'XYZ12345',
    price: 1599,
    item: 'Blue Hedgehog shirt',
})
```

</MultiLanguage>

Later, we can use these properties to filter events based on a particular property value, or to calculate the aggregate values of a property over time.

> **Tip**: Always include more properties than you might need at first!
> There's no limit to the number of properties an event can have, and your future self will thank you once again when you need to access a property that you may not have thought you needed.

### Keeping events consistent and reliable

A second reason why Custom events become important is for keeping tracking consistent and reliable.
When elements of your frontend change, this can affect how autocapture events show up in PostHog.
Continuing with the example above, if we changed the text for our add to cart button to just 'Add', our autocapure events would begin showing up as `Clicked button with text 'Add'` instead of what they had previously been.

While combining these two events using [Actions](/manual/actions) to fix this drift is possible, manually track these high-value actions with custom events is far more reliable.

## 4. Capture backend events <Badge>Optional</Badge> <Badge>Server</Badge>

We've now covered sending events using autocapture and custom tracking, but up until now we've only been sending events from our frontend website.
While for simple websites this is all you'll need to set up, if you're building a web or mobile app with a backend, we also highly recommend setting up tracking from your server in addition to your frontend.

There are several reasons why it's often preferable to send certain custom events from the server-side:

1. **More reliable delivery**: As these events originate from your server, there's no way for them to get accidentally blocked by client-side ad-blockers
2. **More reliable data**: You can fetch up-to-date information directly from your database or other services, which may not be readily available on the frontend

Our [SDK pages](/docs/integrate?tab=sdks) contain information on installing PostHog on your specific platform. Once you have the library installed, you can send a capture event using the same `capture` method as in `posthog-js`.

<SendEventBackend />

The only major difference on the server side is that we must include a `distinct_id` with every event.
Often, this will come in the form of a unique user ID and can be pulled from a session cookie when requests arrive from the client.

### When should I send events from the server vs. the client?

In general, our guidance is to track events on both the frontend and backend whenever possible, to ensure maximum reliability and the most flexibility when analyzing your data.

That being said, there are certain events that we highly recommend tracking from the server-side specifically:

1. **Sign-up events**: Given how high value these events are, they should always be sent from the server-side whenever possible.
2. **C(R)UD events**: This is a broad class of events, but generally speaking, whenever you receive an API request to create or update a specific resource within your application, it's useful to forward these to PostHog. We also recommend including context about the request itself in the event (latency, errors, any properties passed in the request payload, etc.)
3. **Backend jobs**: PostHog is for more than just optimizing your frontend! It can often be useful to send events whenever backend jobs or workflows are kicked off, which allows you to analyze them within PostHog.
